<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>EventHandlerLoader.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">AWS Lambda Java Runtime Interface Client</a> &gt; <a href="index.source.html" class="el_package">com.amazonaws.services.lambda.runtime.api.client</a> &gt; <span class="el_source">EventHandlerLoader.java</span></div><h1>EventHandlerLoader.java</h1><pre class="source lang-java linenums">/* Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved. */

package com.amazonaws.services.lambda.runtime.api.client;

import com.amazonaws.services.lambda.runtime.ClientContext;
import com.amazonaws.services.lambda.runtime.Context;
import com.amazonaws.services.lambda.runtime.RequestHandler;
import com.amazonaws.services.lambda.runtime.RequestStreamHandler;
import com.amazonaws.services.lambda.runtime.LambdaRuntimeInternal;

import com.amazonaws.services.lambda.runtime.api.client.api.LambdaClientContext;
import com.amazonaws.services.lambda.runtime.api.client.api.LambdaCognitoIdentity;
import com.amazonaws.services.lambda.runtime.api.client.api.LambdaContext;
import com.amazonaws.services.lambda.runtime.api.client.util.UnsafeUtil;
import com.amazonaws.services.lambda.runtime.serialization.PojoSerializer;
import com.amazonaws.services.lambda.runtime.serialization.events.LambdaEventSerializers;
import com.amazonaws.services.lambda.runtime.serialization.factories.GsonFactory;
import com.amazonaws.services.lambda.runtime.serialization.factories.JacksonFactory;
import com.amazonaws.services.lambda.runtime.serialization.util.Functions;
import com.amazonaws.services.lambda.runtime.serialization.util.ReflectUtil;
import com.amazonaws.services.lambda.runtime.api.client.LambdaRequestHandler.UserFaultHandler;
import com.amazonaws.services.lambda.runtime.api.client.runtimeapi.InvocationRequest;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.PrintWriter;
import java.io.StringWriter;
import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.lang.reflect.ParameterizedType;
import java.lang.reflect.Type;
import java.lang.reflect.TypeVariable;
import java.util.Arrays;
import java.util.Comparator;
import java.util.EnumMap;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.Map;
import java.util.Optional;

import static com.amazonaws.services.lambda.runtime.api.client.UserFault.filterStackTrace;
import static com.amazonaws.services.lambda.runtime.api.client.UserFault.makeUserFault;
import static com.amazonaws.services.lambda.runtime.api.client.UserFault.trace;

public final class EventHandlerLoader {
<span class="nc" id="L50">    private static final byte[] _JsonNull = new byte[]{'n', 'u', 'l', 'l'};</span>

<span class="nc" id="L52">    private enum Platform {</span>
<span class="nc" id="L53">        ANDROID,</span>
<span class="nc" id="L54">        IOS,</span>
<span class="nc" id="L55">        UNKNOWN</span>
    }

<span class="nc" id="L58">    private static final EnumMap&lt;Platform, Map&lt;Type, PojoSerializer&lt;Object&gt;&gt;&gt; typeCache = new EnumMap&lt;&gt;(Platform.class);</span>

    private EventHandlerLoader() { }

    /**
     * returns the appropriate serializer for the class based on platform and whether the class is a supported event
     * @param platform enum platform
     * @param type Type of object used
     * @return PojoSerializer
     * @see Platform for which platforms are used
     * @see LambdaEventSerializers for how mixins and modules are added to the serializer
     */
    @SuppressWarnings({&quot;unchecked&quot;, &quot;rawtypes&quot;})
    private static PojoSerializer&lt;Object&gt; getSerializer(Platform platform, Type type) {
        // if serializing a Class that is a Lambda supported event, use Jackson with customizations
<span class="nc bnc" id="L73" title="All 2 branches missed.">        if (type instanceof Class) {</span>
<span class="nc" id="L74">            Class&lt;Object&gt; clazz = ((Class)type);</span>
<span class="nc bnc" id="L75" title="All 2 branches missed.">            if (LambdaEventSerializers.isLambdaSupportedEvent(clazz.getName())) {</span>
<span class="nc" id="L76">                return LambdaEventSerializers.serializerFor(clazz, AWSLambda.customerClassLoader);</span>
            }
        }
        // else platform dependent (Android uses GSON but all other platforms use Jackson)
<span class="nc bnc" id="L80" title="All 2 branches missed.">        switch (platform) {</span>
            case ANDROID:
<span class="nc" id="L82">                return GsonFactory.getInstance().getSerializer(type);</span>
            default:
<span class="nc" id="L84">                return JacksonFactory.getInstance().getSerializer(type);</span>
        }
    }

    private static PojoSerializer&lt;Object&gt; getSerializerCached(Platform platform, Type type) {
<span class="nc" id="L89">        Map&lt;Type, PojoSerializer&lt;Object&gt;&gt; cache = typeCache.get(platform);</span>
<span class="nc bnc" id="L90" title="All 2 branches missed.">        if (cache == null) {</span>
<span class="nc" id="L91">            cache = new HashMap&lt;&gt;();</span>
<span class="nc" id="L92">            typeCache.put(platform, cache);</span>
        }

<span class="nc" id="L95">        PojoSerializer&lt;Object&gt; serializer = cache.get(type);</span>
<span class="nc bnc" id="L96" title="All 2 branches missed.">        if (serializer == null) {</span>
<span class="nc" id="L97">            serializer = getSerializer(platform, type);</span>
<span class="nc" id="L98">            cache.put(type, serializer);</span>
        }

<span class="nc" id="L101">        return serializer;</span>
    }

    private static volatile PojoSerializer&lt;LambdaClientContext&gt; contextSerializer;
    private static volatile PojoSerializer&lt;LambdaCognitoIdentity&gt; cognitoSerializer;

    private static PojoSerializer&lt;LambdaClientContext&gt; getContextSerializer() {
<span class="nc bnc" id="L108" title="All 2 branches missed.">        if (contextSerializer == null) {</span>
<span class="nc" id="L109">            contextSerializer = GsonFactory.getInstance().getSerializer(LambdaClientContext.class);</span>
        }
<span class="nc" id="L111">        return contextSerializer;</span>
    }

    private static PojoSerializer&lt;LambdaCognitoIdentity&gt; getCognitoSerializer() {
<span class="nc bnc" id="L115" title="All 2 branches missed.">        if (cognitoSerializer == null) {</span>
<span class="nc" id="L116">            cognitoSerializer = GsonFactory.getInstance().getSerializer(LambdaCognitoIdentity.class);</span>
        }
<span class="nc" id="L118">        return cognitoSerializer;</span>
    }


    private static Platform getPlatform(Context context) {
<span class="nc" id="L123">        ClientContext cc = context.getClientContext();</span>
<span class="nc bnc" id="L124" title="All 2 branches missed.">        if (cc == null) {</span>
<span class="nc" id="L125">            return Platform.UNKNOWN;</span>
        }

<span class="nc" id="L128">        Map&lt;String, String&gt; env = cc.getEnvironment();</span>
<span class="nc bnc" id="L129" title="All 2 branches missed.">        if (env == null) {</span>
<span class="nc" id="L130">            return Platform.UNKNOWN;</span>
        }

<span class="nc" id="L133">        String platform = env.get(&quot;platform&quot;);</span>
<span class="nc bnc" id="L134" title="All 2 branches missed.">        if (platform == null) {</span>
<span class="nc" id="L135">            return Platform.UNKNOWN;</span>
        }

<span class="nc bnc" id="L138" title="All 2 branches missed.">        if (&quot;Android&quot;.equalsIgnoreCase(platform)) {</span>
<span class="nc" id="L139">            return Platform.ANDROID;</span>
<span class="nc bnc" id="L140" title="All 2 branches missed.">        } else if (&quot;iPhoneOS&quot;.equalsIgnoreCase(platform)) {</span>
<span class="nc" id="L141">            return Platform.IOS;</span>
        } else {
<span class="nc" id="L143">            return Platform.UNKNOWN;</span>
        }
    }

    private static boolean isVoid(Type type) {
<span class="nc bnc" id="L148" title="All 6 branches missed.">        return Void.TYPE.equals(type) || (type instanceof Class) &amp;&amp; Void.class.isAssignableFrom((Class&lt;?&gt;)type);</span>
    }

    /**
     * Wraps a RequestHandler as a lower level stream handler using supplied types.
     * Optional types mean that the input and/or output should be ignored respectiveley
     */
    @SuppressWarnings(&quot;rawtypes&quot;)
    private static final class PojoHandlerAsStreamHandler implements RequestStreamHandler {

        public RequestHandler innerHandler;
        public final Optional&lt;Type&gt; inputType;
        public final Optional&lt;Type&gt; outputType;

        public PojoHandlerAsStreamHandler(
                RequestHandler innerHandler,
                Optional&lt;Type&gt; inputType,
                Optional&lt;Type&gt; outputType
<span class="nc" id="L166">        ) {</span>
<span class="nc" id="L167">            this.innerHandler = innerHandler;</span>
<span class="nc" id="L168">            this.inputType = inputType;</span>
<span class="nc" id="L169">            this.outputType = outputType;</span>


<span class="nc bnc" id="L172" title="All 2 branches missed.">            if (inputType.isPresent()) {</span>
<span class="nc" id="L173">                getSerializerCached(Platform.UNKNOWN, inputType.get());</span>
            }

<span class="nc bnc" id="L176" title="All 2 branches missed.">            if (outputType.isPresent()) {</span>
<span class="nc" id="L177">                getSerializerCached(Platform.UNKNOWN, outputType.get());</span>
            }
<span class="nc" id="L179">        }</span>

        @SuppressWarnings(&quot;unchecked&quot;)
        @Override
        public void handleRequest(InputStream inputStream, OutputStream outputStream, Context context)
                throws IOException {
            final Object input;
<span class="nc" id="L186">            final Platform platform = getPlatform(context);</span>
            try {
<span class="nc bnc" id="L188" title="All 2 branches missed.">                if (inputType.isPresent()) {</span>
<span class="nc" id="L189">                    input = getSerializerCached(platform, inputType.get()).fromJson(inputStream);</span>
                } else {
<span class="nc" id="L191">                    input = null;</span>
                }
<span class="nc" id="L193">            } catch (Throwable t) {</span>
<span class="nc" id="L194">                throw new RuntimeException(&quot;An error occurred during JSON parsing&quot;, filterStackTrace(t));</span>
<span class="nc" id="L195">            }</span>

            final Object output;
            try {
<span class="nc" id="L199">                output = innerHandler.handleRequest(input, context);</span>
<span class="nc" id="L200">            } catch (Throwable t) {</span>
<span class="nc" id="L201">                throw UnsafeUtil.throwException(filterStackTrace(t));</span>
<span class="nc" id="L202">            }</span>

            try {
<span class="nc bnc" id="L205" title="All 2 branches missed.">                if (outputType.isPresent()) {</span>
<span class="nc" id="L206">                    PojoSerializer&lt;Object&gt; serializer = getSerializerCached(platform, outputType.get());</span>
<span class="nc" id="L207">                    serializer.toJson(output, outputStream);</span>
<span class="nc" id="L208">                } else {</span>
<span class="nc" id="L209">                    outputStream.write(_JsonNull);</span>
                }
<span class="nc" id="L211">            } catch (Throwable t) {</span>
<span class="nc" id="L212">                throw new RuntimeException(&quot;An error occurred during JSON serialization of response&quot;, t);</span>
<span class="nc" id="L213">            }</span>
<span class="nc" id="L214">        }</span>
    }

    /**
     * Wraps a java.lang.reflect.Method as a POJO RequestHandler
     */
    private static final class PojoMethodRequestHandler implements RequestHandler&lt;Object, Object&gt; {
        public final Method m;
        public final Type pType;
        public final Object instance;
        public final boolean needsContext;
        public final int argSize;

<span class="nc" id="L227">        public PojoMethodRequestHandler(Method m, Type pType, Type rType, Object instance, boolean needsContext) {</span>
<span class="nc" id="L228">            this.m = m;</span>
<span class="nc" id="L229">            this.pType = pType;</span>
<span class="nc" id="L230">            this.instance = instance;</span>
<span class="nc" id="L231">            this.needsContext = needsContext;</span>
<span class="nc bnc" id="L232" title="All 4 branches missed.">            this.argSize = (needsContext ? 1 : 0) + (pType != null ? 1 : 0);</span>
<span class="nc" id="L233">        }</span>

        public static PojoMethodRequestHandler fromMethod(
                Class&lt;?&gt; clazz,
                Method m,
                Type pType,
                Type rType,
                boolean needsContext
        ) throws Exception {
            final Object instance;
<span class="nc bnc" id="L243" title="All 2 branches missed.">            if (Modifier.isStatic(m.getModifiers())) {</span>
<span class="nc" id="L244">                instance = null;</span>
            } else {
<span class="nc" id="L246">                instance = newInstance(getConstructor(clazz));</span>
            }

<span class="nc" id="L249">            return new PojoMethodRequestHandler(m, pType, rType, instance, needsContext);</span>
        }

        public static LambdaRequestHandler makeRequestHandler(
                Class&lt;?&gt; clazz,
                Method m,
                Type pType,
                Type rType,
                boolean needsContext
        ) {
            try {
<span class="nc" id="L260">                return wrapPojoHandler(fromMethod(clazz, m, pType, rType, needsContext), pType, rType);</span>
<span class="nc" id="L261">            } catch (UserFault f) {</span>
<span class="nc" id="L262">                return new UserFaultHandler(f);</span>
<span class="nc" id="L263">            } catch (Throwable t) {</span>
<span class="nc" id="L264">                return new UserFaultHandler(makeUserFault(t));</span>
            }
        }

        @Override
        public Object handleRequest(Object input, Context context) {
<span class="nc" id="L270">            final Object[] args = new Object[argSize];</span>
<span class="nc" id="L271">            int idx = 0;</span>

<span class="nc bnc" id="L273" title="All 2 branches missed.">            if (pType != null) {</span>
<span class="nc" id="L274">                args[idx++] = input;</span>
            }

<span class="nc bnc" id="L277" title="All 2 branches missed.">            if (this.needsContext) {</span>
<span class="nc" id="L278">                args[idx++] = context;</span>
            }

            try {
<span class="nc" id="L282">                return m.invoke(this.instance, args);</span>
<span class="nc" id="L283">            } catch (InvocationTargetException e) {</span>
<span class="nc bnc" id="L284" title="All 2 branches missed.">                if (e.getCause() != null) {</span>
<span class="nc" id="L285">                    throw UnsafeUtil.throwException(filterStackTrace(e.getCause()));</span>
                } else {
<span class="nc" id="L287">                    throw UnsafeUtil.throwException(filterStackTrace(e));</span>
                }
<span class="nc" id="L289">            } catch (Throwable t) {</span>
<span class="nc" id="L290">                throw UnsafeUtil.throwException(filterStackTrace(t));</span>
            }
        }
    }

    /**
     * Wraps a java.lang.reflect.Method object as a RequestStreamHandler
     */
    private static final class StreamMethodRequestHandler implements RequestStreamHandler {
        public final Method m;
        public final Object instance;
        public final boolean needsInput;
        public final boolean needsOutput;
        public final boolean needsContext;
        public final int argSize;

        public StreamMethodRequestHandler(
                Method m,
                Object instance,
                boolean needsInput,
                boolean needsOutput,
                boolean needsContext
<span class="nc" id="L312">        ) {</span>
<span class="nc" id="L313">            this.m = m;</span>
<span class="nc" id="L314">            this.instance = instance;</span>
<span class="nc" id="L315">            this.needsInput = needsInput;</span>
<span class="nc" id="L316">            this.needsOutput = needsOutput;</span>
<span class="nc" id="L317">            this.needsContext = needsContext;</span>
<span class="nc bnc" id="L318" title="All 6 branches missed.">            this.argSize = (needsInput ? 1 : 0) + (needsOutput ? 1 : 0) + (needsContext ? 1 : 0);</span>
<span class="nc" id="L319">        }</span>

        public static StreamMethodRequestHandler fromMethod(
                Class&lt;?&gt; clazz,
                Method m,
                boolean needsInput,
                boolean needsOutput,
                boolean needsContext
        ) throws Exception {
<span class="nc bnc" id="L328" title="All 2 branches missed.">            if (!isVoid(m.getReturnType())) {</span>
<span class="nc" id="L329">                System.err.println(&quot;Will ignore return type &quot; + m.getReturnType() + &quot; on byte stream handler&quot;);</span>
            }
<span class="nc bnc" id="L331" title="All 2 branches missed.">            final Object instance = Modifier.isStatic(m.getModifiers())</span>
<span class="nc" id="L332">                    ? null</span>
<span class="nc" id="L333">                    : newInstance(getConstructor(clazz));</span>

<span class="nc" id="L335">            return new StreamMethodRequestHandler(m, instance, needsInput, needsOutput, needsContext);</span>
        }

        public static LambdaRequestHandler makeRequestHandler(
                Class&lt;?&gt; clazz,
                Method m,
                boolean needsInput,
                boolean needsOutput,
                boolean needsContext
        ) {
            try {
<span class="nc" id="L346">                return wrapRequestStreamHandler(fromMethod(clazz, m, needsInput, needsOutput, needsContext));</span>
<span class="nc" id="L347">            } catch (UserFault f) {</span>
<span class="nc" id="L348">                return new UserFaultHandler(f);</span>
<span class="nc" id="L349">            } catch (Throwable t) {</span>
<span class="nc" id="L350">                return new UserFaultHandler(makeUserFault(t));</span>
            }
        }

        @Override
        public void handleRequest(InputStream inputStream, OutputStream outputStream, Context context)
                throws IOException {
<span class="nc" id="L357">            final Object[] args = new Object[argSize];</span>
<span class="nc" id="L358">            int idx = 0;</span>

<span class="nc bnc" id="L360" title="All 2 branches missed.">            if (needsInput) {</span>
<span class="nc" id="L361">                args[idx++] = inputStream;</span>
            } else {
<span class="nc" id="L363">                inputStream.close();</span>
            }

<span class="nc bnc" id="L366" title="All 2 branches missed.">            if (needsOutput) {</span>
<span class="nc" id="L367">                args[idx++] = outputStream;</span>
            }

<span class="nc bnc" id="L370" title="All 2 branches missed.">            if (needsContext) {</span>
<span class="nc" id="L371">                args[idx++] = context;</span>
            }

            try {
<span class="nc" id="L375">                m.invoke(this.instance, args);</span>
<span class="nc bnc" id="L376" title="All 2 branches missed.">                if (!needsOutput) {</span>
<span class="nc" id="L377">                    outputStream.write(_JsonNull);</span>
                }
<span class="nc" id="L379">            } catch (InvocationTargetException e) {</span>
<span class="nc bnc" id="L380" title="All 2 branches missed.">                if (e.getCause() != null) {</span>
<span class="nc" id="L381">                    throw UnsafeUtil.throwException(filterStackTrace(e.getCause()));</span>
                } else {
<span class="nc" id="L383">                    throw UnsafeUtil.throwException(filterStackTrace(e));</span>
                }
<span class="nc" id="L385">            } catch (Throwable t) {</span>
<span class="nc" id="L386">                throw UnsafeUtil.throwException(filterStackTrace(t));</span>
<span class="nc" id="L387">            }</span>
<span class="nc" id="L388">        }</span>
    }

    public static &lt;T&gt; Constructor&lt;T&gt; getConstructor(Class&lt;T&gt; clazz) throws Exception {
        final Constructor&lt;T&gt; constructor;
        try {
<span class="nc" id="L394">            constructor = clazz.getConstructor();</span>
<span class="nc" id="L395">        } catch (NoSuchMethodException e) {</span>
<span class="nc bnc" id="L396" title="All 4 branches missed.">            if (clazz.getEnclosingClass() != null &amp;&amp; !Modifier.isStatic(clazz.getModifiers())) {</span>
<span class="nc" id="L397">                throw new Exception(&quot;Class &quot;</span>
<span class="nc" id="L398">                        + clazz.getName()</span>
                        + &quot; cannot be instantiated because it is a non-static inner class&quot;);
            } else {
<span class="nc" id="L401">                throw new Exception(&quot;Class &quot; + clazz.getName() + &quot; has no public zero-argument constructor&quot;, e);</span>
            }
<span class="nc" id="L403">        }</span>
<span class="nc" id="L404">        return constructor;</span>
    }

    public static &lt;T&gt; T newInstance(Constructor&lt;? extends T&gt; constructor) {
        try {
<span class="nc" id="L409">            return constructor.newInstance();</span>
<span class="nc" id="L410">        } catch (UserFault e) {</span>
<span class="nc" id="L411">            throw e;</span>
<span class="nc" id="L412">        } catch (InvocationTargetException e) {</span>
<span class="nc bnc" id="L413" title="All 2 branches missed.">            throw makeUserFault(e.getCause() == null ? e : e.getCause(), true);</span>
<span class="nc" id="L414">        } catch (InstantiationException e) {</span>
<span class="nc bnc" id="L415" title="All 2 branches missed.">            throw UnsafeUtil.throwException(e.getCause() == null ? e : e.getCause());</span>
<span class="nc" id="L416">        } catch (IllegalAccessException e) {</span>
<span class="nc" id="L417">            throw UnsafeUtil.throwException(e);</span>
        }
    }

    private static final class ClassContext {
        public final Class&lt;?&gt; clazz;
        public final Type[] actualTypeArguments;

        @SuppressWarnings({&quot;rawtypes&quot;})
        private TypeVariable[] typeParameters;

<span class="nc" id="L428">        public ClassContext(Class&lt;?&gt; clazz, Type[] actualTypeArguments) {</span>
<span class="nc" id="L429">            this.clazz = clazz;</span>
<span class="nc" id="L430">            this.actualTypeArguments = actualTypeArguments;</span>
<span class="nc" id="L431">        }</span>

        @SuppressWarnings({&quot;rawtypes&quot;})
<span class="nc" id="L434">        public ClassContext(Class&lt;?&gt; clazz, ClassContext curContext) {</span>
<span class="nc" id="L435">            this.typeParameters = clazz.getTypeParameters();</span>
<span class="nc bnc" id="L436" title="All 4 branches missed.">            if (typeParameters.length == 0 || curContext.actualTypeArguments == null) {</span>
<span class="nc" id="L437">                this.clazz = clazz;</span>
<span class="nc" id="L438">                this.actualTypeArguments = null;</span>
            } else {
<span class="nc" id="L440">                Type[] types = new Type[typeParameters.length];</span>
<span class="nc bnc" id="L441" title="All 2 branches missed.">                for (int i = 0; i &lt; types.length; i++) {</span>
<span class="nc" id="L442">                    types[i] = curContext.resolveTypeVariable(typeParameters[i]);</span>
                }

<span class="nc" id="L445">                this.clazz = clazz;</span>
<span class="nc" id="L446">                this.actualTypeArguments = types;</span>
            }
<span class="nc" id="L448">        }</span>

        @SuppressWarnings({&quot;rawtypes&quot;})
<span class="nc" id="L451">        public ClassContext(ParameterizedType type, ClassContext curContext) {</span>
<span class="nc" id="L452">            Type[] types = type.getActualTypeArguments();</span>
<span class="nc bnc" id="L453" title="All 2 branches missed.">            for (int i = 0; i &lt; types.length; i++) {</span>
<span class="nc" id="L454">                Type t = types[i];</span>
<span class="nc bnc" id="L455" title="All 2 branches missed.">                if (t instanceof TypeVariable) {</span>
<span class="nc" id="L456">                    types[i] = curContext.resolveTypeVariable((TypeVariable)t);</span>
                }
            }

<span class="nc" id="L460">            Type t = type.getRawType();</span>
<span class="nc bnc" id="L461" title="All 2 branches missed.">            if (t instanceof Class) {</span>
<span class="nc" id="L462">                this.clazz = (Class)t;</span>
<span class="nc bnc" id="L463" title="All 2 branches missed.">            } else if (t instanceof TypeVariable) {</span>
<span class="nc" id="L464">                this.clazz = (Class)((TypeVariable)t).getGenericDeclaration();</span>
            } else {
<span class="nc" id="L466">                throw new RuntimeException(&quot;Type &quot; + t + &quot; is of unexpected type &quot; + t.getClass());</span>
            }
<span class="nc" id="L468">            this.actualTypeArguments = types;</span>
<span class="nc" id="L469">        }</span>

        @SuppressWarnings({&quot;rawtypes&quot;})
        public Type resolveTypeVariable(TypeVariable t) {
<span class="nc" id="L473">            TypeVariable[] variables = getTypeParameters();</span>
<span class="nc bnc" id="L474" title="All 2 branches missed.">            for (int i = 0; i &lt; variables.length; i++) {</span>
<span class="nc bnc" id="L475" title="All 2 branches missed.">                if (t.getName().equals(variables[i].getName())) {</span>
<span class="nc bnc" id="L476" title="All 2 branches missed.">                    return actualTypeArguments == null ? variables[i] : actualTypeArguments[i];</span>
                }
            }

<span class="nc" id="L480">            return t;</span>
        }

        @SuppressWarnings({&quot;rawtypes&quot;})
        private TypeVariable[] getTypeParameters() {
<span class="nc bnc" id="L485" title="All 2 branches missed.">            if (typeParameters == null) {</span>
<span class="nc" id="L486">                typeParameters = clazz.getTypeParameters();</span>
            }
<span class="nc" id="L488">            return typeParameters;</span>
        }
    }

    /**
     * perform a breadth-first search for the first parameterized type for iface
     *
     * @return null of no type found. Otherwise the type found.
     */
    public static Type[] findInterfaceParameters(Class&lt;?&gt; clazz, Class&lt;?&gt; iface) {
<span class="nc" id="L498">        LinkedList&lt;ClassContext&gt; clazzes = new LinkedList&lt;&gt;();</span>
<span class="nc" id="L499">        clazzes.addFirst(new ClassContext(clazz, (Type[])null));</span>
<span class="nc bnc" id="L500" title="All 2 branches missed.">        while (!clazzes.isEmpty()) {</span>
<span class="nc" id="L501">            final ClassContext curContext = clazzes.removeLast();</span>
<span class="nc" id="L502">            Type[] interfaces = curContext.clazz.getGenericInterfaces();</span>

<span class="nc bnc" id="L504" title="All 2 branches missed.">            for (Type type : interfaces) {</span>
<span class="nc bnc" id="L505" title="All 2 branches missed.">                if (type instanceof ParameterizedType) {</span>
<span class="nc" id="L506">                    ParameterizedType candidate = (ParameterizedType)type;</span>
<span class="nc" id="L507">                    Type rawType = candidate.getRawType();</span>
<span class="nc bnc" id="L508" title="All 2 branches missed.">                    if (!(rawType instanceof Class)) {</span>
                        //should be impossible
<span class="nc" id="L510">                        System.err.println(&quot;raw type is not a class: &quot; + rawType);</span>
<span class="nc" id="L511">                        continue;</span>
                    }
<span class="nc" id="L513">                    Class&lt;?&gt; rawClass = (Class&lt;?&gt;)rawType;</span>
<span class="nc bnc" id="L514" title="All 2 branches missed.">                    if (iface.isAssignableFrom(rawClass)) {</span>
<span class="nc" id="L515">                        return new ClassContext(candidate, curContext).actualTypeArguments;</span>
                    } else {
<span class="nc" id="L517">                        clazzes.addFirst(new ClassContext(candidate, curContext));</span>
                    }
<span class="nc bnc" id="L519" title="All 2 branches missed.">                } else if (type instanceof Class) {</span>
<span class="nc" id="L520">                    clazzes.addFirst(new ClassContext((Class&lt;?&gt;)type, curContext));</span>
                } else {
                    //should never happen?
<span class="nc" id="L523">                    System.err.println(&quot;Unexpected type class &quot; + type.getClass().getName());</span>
                }
            }

<span class="nc" id="L527">            final Type superClass = curContext.clazz.getGenericSuperclass();</span>
<span class="nc bnc" id="L528" title="All 2 branches missed.">            if (superClass instanceof ParameterizedType) {</span>
<span class="nc" id="L529">                clazzes.addFirst(new ClassContext((ParameterizedType)superClass, curContext));</span>
<span class="nc bnc" id="L530" title="All 2 branches missed.">            } else if (superClass != null) {</span>
<span class="nc" id="L531">                clazzes.addFirst(new ClassContext((Class&lt;?&gt;)superClass, curContext));</span>
            }
<span class="nc" id="L533">        }</span>
<span class="nc" id="L534">        return null;</span>
    }


    @SuppressWarnings({&quot;rawtypes&quot;})
    public static LambdaRequestHandler wrapRequestHandlerClass(final Class&lt;? extends RequestHandler&gt; clazz) {
<span class="nc" id="L540">        Type[] ptypes = findInterfaceParameters(clazz, RequestHandler.class);</span>
<span class="nc bnc" id="L541" title="All 2 branches missed.">        if (ptypes == null) {</span>
<span class="nc" id="L542">            return new UserFaultHandler(makeUserFault(&quot;Class &quot;</span>
<span class="nc" id="L543">                    + clazz.getName()</span>
                    + &quot; does not implement RequestHandler with concrete type parameters&quot;));
        }
<span class="nc bnc" id="L546" title="All 2 branches missed.">        if (ptypes.length != 2) {</span>
<span class="nc" id="L547">            return new UserFaultHandler(makeUserFault(</span>
                    &quot;Invalid class signature for RequestHandler. Expected two generic types, got &quot; + ptypes.length));
        }

<span class="nc bnc" id="L551" title="All 2 branches missed.">        for (Type t : ptypes) {</span>
<span class="nc bnc" id="L552" title="All 2 branches missed.">            if (t instanceof TypeVariable) {</span>
<span class="nc" id="L553">                Type[] bounds = ((TypeVariable)t).getBounds();</span>
<span class="nc" id="L554">                boolean foundBound = false;</span>
<span class="nc bnc" id="L555" title="All 2 branches missed.">                if (bounds != null) {</span>
<span class="nc bnc" id="L556" title="All 2 branches missed.">                    for (Type bound : bounds) {</span>
<span class="nc bnc" id="L557" title="All 2 branches missed.">                        if (!Object.class.equals(bound)) {</span>
<span class="nc" id="L558">                            foundBound = true;</span>
<span class="nc" id="L559">                            break;</span>
                        }
                    }
                }

<span class="nc bnc" id="L564" title="All 2 branches missed.">                if (!foundBound) {</span>
<span class="nc" id="L565">                    return new UserFaultHandler(makeUserFault(&quot;Class &quot; + clazz.getName()</span>
                            + &quot; does not implement RequestHandler with concrete type parameters: parameter &quot;
                            + t + &quot; has no upper bound.&quot;));
                }
            }
        }

<span class="nc" id="L572">        final Type pType = ptypes[0];</span>
<span class="nc" id="L573">        final Type rType = ptypes[1];</span>

        final Constructor&lt;? extends RequestHandler&gt; constructor;
        try {
<span class="nc" id="L577">            constructor = getConstructor(clazz);</span>
<span class="nc" id="L578">            return wrapPojoHandler(newInstance(constructor), pType, rType);</span>
<span class="nc" id="L579">        } catch (UserFault f) {</span>
<span class="nc" id="L580">            return new UserFaultHandler(f);</span>
<span class="nc" id="L581">        } catch (Throwable e) {</span>
<span class="nc" id="L582">            return new UserFaultHandler(makeUserFault(e));</span>
        }
    }

    public static LambdaRequestHandler wrapRequestStreamHandlerClass(final Class&lt;? extends RequestStreamHandler&gt; clazz) {
        final Constructor&lt;? extends RequestStreamHandler&gt; constructor;
        try {
<span class="nc" id="L589">            constructor = getConstructor(clazz);</span>
<span class="nc" id="L590">            return wrapRequestStreamHandler(newInstance(constructor));</span>
<span class="nc" id="L591">        } catch (UserFault f) {</span>
<span class="nc" id="L592">            return new UserFaultHandler(f);</span>
<span class="nc" id="L593">        } catch (Throwable e) {</span>
<span class="nc" id="L594">            return new UserFaultHandler(makeUserFault(e));</span>
        }
    }

    public static LambdaRequestHandler loadStreamingRequestHandler(Class&lt;?&gt; clazz) {
<span class="nc bnc" id="L599" title="All 2 branches missed.">        if (RequestStreamHandler.class.isAssignableFrom(clazz)) {</span>
<span class="nc" id="L600">            return wrapRequestStreamHandlerClass(clazz.asSubclass(RequestStreamHandler.class));</span>
<span class="nc bnc" id="L601" title="All 2 branches missed.">        } else if (RequestHandler.class.isAssignableFrom(clazz)) {</span>
<span class="nc" id="L602">            return wrapRequestHandlerClass(clazz.asSubclass(RequestHandler.class));</span>
        } else {
<span class="nc" id="L604">            return new UserFaultHandler(makeUserFault(&quot;Class does not implement an appropriate handler interface: &quot;</span>
<span class="nc" id="L605">                    + clazz.getName()));</span>
        }
    }

    public static LambdaRequestHandler loadEventHandler(HandlerInfo handlerInfo) {
<span class="nc bnc" id="L610" title="All 2 branches missed.">        if (handlerInfo.methodName == null) {</span>
<span class="nc" id="L611">            return loadStreamingRequestHandler(handlerInfo.clazz);</span>
        } else {
<span class="nc" id="L613">            return loadEventPojoHandler(handlerInfo);</span>
        }
    }

    private static Optional&lt;LambdaRequestHandler&gt; getOneLengthHandler(
            Class&lt;?&gt; clazz,
            Method m,
            Type pType,
            Type rType
    ) {
<span class="nc bnc" id="L623" title="All 2 branches missed.">        if (InputStream.class.equals(pType)) {</span>
<span class="nc" id="L624">            return Optional.of(StreamMethodRequestHandler.makeRequestHandler(clazz, m, true, false, false));</span>
<span class="nc bnc" id="L625" title="All 2 branches missed.">        } else if (OutputStream.class.equals(pType)) {</span>
<span class="nc" id="L626">            return Optional.of(StreamMethodRequestHandler.makeRequestHandler(clazz, m, false, true, false));</span>
<span class="nc bnc" id="L627" title="All 2 branches missed.">        } else if (isContext(pType)) {</span>
<span class="nc" id="L628">            return Optional.of(PojoMethodRequestHandler.makeRequestHandler(clazz, m, null, rType, true));</span>
        } else {
<span class="nc" id="L630">            return Optional.of(PojoMethodRequestHandler.makeRequestHandler(clazz, m, pType, rType, false));</span>
        }
    }

    private static Optional&lt;LambdaRequestHandler&gt; getTwoLengthHandler(
            Class&lt;?&gt; clazz,
            Method m,
            Type pType1,
            Type pType2,
            Type rType
    ) {
<span class="nc bnc" id="L641" title="All 2 branches missed.">        if (OutputStream.class.equals(pType1)) {</span>
<span class="nc bnc" id="L642" title="All 2 branches missed.">            if (isContext(pType2)) {</span>
<span class="nc" id="L643">                return Optional.of(StreamMethodRequestHandler.makeRequestHandler(clazz, m, false, true, true));</span>
            } else {
<span class="nc" id="L645">                System.err.println(</span>
                        &quot;Ignoring two-argument overload because first argument type is OutputStream and second argument type is not Context&quot;);
<span class="nc" id="L647">                return Optional.empty();</span>
            }
<span class="nc bnc" id="L649" title="All 2 branches missed.">        } else if (isContext(pType1)) {</span>
<span class="nc" id="L650">            System.err.println(&quot;Ignoring two-argument overload because first argument type is Context&quot;);</span>
<span class="nc" id="L651">            return Optional.empty();</span>
<span class="nc bnc" id="L652" title="All 2 branches missed.">        } else if (InputStream.class.equals(pType1)) {</span>
<span class="nc bnc" id="L653" title="All 2 branches missed.">            if (OutputStream.class.equals(pType2)) {</span>
<span class="nc" id="L654">                return Optional.of(StreamMethodRequestHandler.makeRequestHandler(clazz, m, true, true, false));</span>
<span class="nc bnc" id="L655" title="All 2 branches missed.">            } else if (isContext(pType2)) {</span>
<span class="nc" id="L656">                return Optional.of(StreamMethodRequestHandler.makeRequestHandler(clazz, m, true, false, true));</span>
            } else {
<span class="nc" id="L658">                System.err.println(&quot;Ignoring two-argument overload because second parameter type, &quot;</span>
<span class="nc" id="L659">                        + ReflectUtil.getRawClass(pType2).getName()</span>
                        + &quot;, is not OutputStream.&quot;);
<span class="nc" id="L661">                return Optional.empty();</span>
            }
<span class="nc bnc" id="L663" title="All 2 branches missed.">        } else if (isContext(pType2)) {</span>
<span class="nc" id="L664">            return Optional.of(PojoMethodRequestHandler.makeRequestHandler(clazz, m, pType1, rType, true));</span>
        } else {
<span class="nc" id="L666">            System.err.println(&quot;Ignoring two-argument overload because second parameter type is not Context&quot;);</span>
<span class="nc" id="L667">            return Optional.empty();</span>
        }
    }

    private static Optional&lt;LambdaRequestHandler&gt; getThreeLengthHandler(
            Class&lt;?&gt; clazz,
            Method m,
            Type pType1,
            Type pType2,
            Type pType3,
            Type rType
    ) {
<span class="nc bnc" id="L679" title="All 6 branches missed.">        if (InputStream.class.equals(pType1) &amp;&amp; OutputStream.class.equals(pType2) &amp;&amp; isContext(pType3)) {</span>
<span class="nc" id="L680">            return Optional.of(StreamMethodRequestHandler.makeRequestHandler(clazz, m, true, true, true));</span>
        } else {
<span class="nc" id="L682">            System.err.println(</span>
                    &quot;Ignoring three-argument overload because argument signature is not (InputStream, OutputStream, Context&quot;);
<span class="nc" id="L684">            return Optional.empty();</span>
        }
    }

    private static Optional&lt;LambdaRequestHandler&gt; getHandlerFromOverload(Class&lt;?&gt; clazz, Method m) {
<span class="nc" id="L689">        final Type rType = m.getGenericReturnType();</span>
<span class="nc" id="L690">        final Type[] pTypes = m.getGenericParameterTypes();</span>

<span class="nc bnc" id="L692" title="All 2 branches missed.">        if (pTypes.length == 0) {</span>
<span class="nc" id="L693">            return Optional.of(PojoMethodRequestHandler.makeRequestHandler(clazz, m, null, rType, false));</span>
<span class="nc bnc" id="L694" title="All 2 branches missed.">        } else if (pTypes.length == 1) {</span>
<span class="nc" id="L695">            return getOneLengthHandler(clazz, m, pTypes[0], rType);</span>
<span class="nc bnc" id="L696" title="All 2 branches missed.">        } else if (pTypes.length == 2) {</span>
<span class="nc" id="L697">            return getTwoLengthHandler(clazz, m, pTypes[0], pTypes[1], rType);</span>
<span class="nc bnc" id="L698" title="All 2 branches missed.">        } else if (pTypes.length == 3) {</span>
<span class="nc" id="L699">            return getThreeLengthHandler(clazz, m, pTypes[0], pTypes[1], pTypes[2], rType);</span>
        } else {
<span class="nc" id="L701">            System.err.println(&quot;Ignoring an overload of method &quot;</span>
<span class="nc" id="L702">                    + m.getName()</span>
                    + &quot; because it has too many parameters: Expected at most 3, got &quot;
                    + pTypes.length);
<span class="nc" id="L705">            return Optional.empty();</span>
        }
    }

    private static final boolean isContext(Type t) {
<span class="nc" id="L710">        return Context.class.equals(t);</span>
    }

    /**
     * Returns true if the last type in params is a lambda context object interface (Context).
     */
    private static final boolean lastParameterIsContext(Class&lt;?&gt;[] params) {
<span class="nc bnc" id="L717" title="All 4 branches missed.">        return params.length != 0 &amp;&amp; isContext(params[params.length - 1]);</span>
    }

    /**
     * Implement a comparator for Methods. We sort overloaded handler methods using this comparator, and then pick the
     * lowest sorted method.
     */
<span class="nc" id="L724">    private static final Comparator&lt;Method&gt; methodPriority = new Comparator&lt;Method&gt;() {</span>
        public int compare(Method lhs, Method rhs) {

            //1. Non bridge methods are preferred over bridge methods.
<span class="nc bnc" id="L728" title="All 4 branches missed.">            if (! lhs.isBridge() &amp;&amp; rhs.isBridge()) {</span>
<span class="nc" id="L729">                return -1;</span>
            }
<span class="nc bnc" id="L731" title="All 4 branches missed.">            else if (!rhs.isBridge() &amp;&amp; lhs.isBridge()) {</span>
<span class="nc" id="L732">                return 1;</span>
            }

            //2. We prefer longer signatures to shorter signatures. Except we count a method whose last argument is
            //Context as having 1 more argument than it really does. This is a stupid thing to do, but we
            //need to keep it for back compat reasons.
<span class="nc" id="L738">            Class&lt;?&gt;[] lParams = lhs.getParameterTypes();</span>
<span class="nc" id="L739">            Class&lt;?&gt;[] rParams = rhs.getParameterTypes();</span>

<span class="nc" id="L741">            int lParamCompareLength = lParams.length;</span>
<span class="nc" id="L742">            int rParamCompareLength = rParams.length;</span>

<span class="nc bnc" id="L744" title="All 2 branches missed.">            if (lastParameterIsContext(lParams)) {</span>
<span class="nc" id="L745">                ++lParamCompareLength;</span>
            }

<span class="nc bnc" id="L748" title="All 2 branches missed.">            if (lastParameterIsContext(rParams)) {</span>
<span class="nc" id="L749">                ++rParamCompareLength;</span>
            }

<span class="nc" id="L752">            return -Integer.compare(lParamCompareLength, rParamCompareLength);</span>
        }
    };

    private static LambdaRequestHandler loadEventPojoHandler(HandlerInfo handlerInfo) {
        Method[] methods;
        try {
<span class="nc" id="L759">            methods = handlerInfo.clazz.getMethods();</span>
<span class="nc" id="L760">        } catch (NoClassDefFoundError e) {</span>
<span class="nc" id="L761">            return new LambdaRequestHandler.UserFaultHandler(new UserFault(</span>
<span class="nc" id="L762">                    &quot;Error loading method &quot; + handlerInfo.methodName + &quot; on class &quot; + handlerInfo.clazz.getName(),</span>
<span class="nc" id="L763">                    e.getClass().getName(),</span>
<span class="nc" id="L764">                    trace(e)</span>
            ));
<span class="nc" id="L766">        }</span>
<span class="nc bnc" id="L767" title="All 2 branches missed.">        if (methods.length == 0) {</span>
<span class="nc" id="L768">            final String msg = &quot;Class &quot;</span>
<span class="nc" id="L769">                    + handlerInfo.getClass().getName()</span>
                    + &quot; has no public method named &quot;
                    + handlerInfo.methodName;
<span class="nc" id="L772">            return new UserFaultHandler(makeUserFault(msg));</span>
        }

        /*
         * We support the following signatures
         * Anything (InputStream, OutputStream, Context)
         * Anything (InputStream, OutputStream)
         * Anything (OutputStream, Context)
         * Anything (InputStream, Context)
         * Anything (InputStream)
         * Anything (OutputStream)
         * Anything (Context)
         * Anything (AlmostAnything, Context)
         * Anything (AlmostAnything)
         * Anything ()
         *
         * where AlmostAnything is any type except InputStream, OutputStream, Context
         * Anything represents any type (primitive, void, or Object)
         *
         * prefer methods with longer signatures, add extra weight to those ending with a Context object
         *
         */

<span class="nc" id="L795">        int slide = 0;</span>

<span class="nc bnc" id="L797" title="All 2 branches missed.">        for (int i = 0; i &lt; methods.length; i++) {</span>
<span class="nc" id="L798">            Method m = methods[i];</span>
<span class="nc" id="L799">            methods[i - slide] = m;</span>
<span class="nc bnc" id="L800" title="All 2 branches missed.">            if (!m.getName().equals(handlerInfo.methodName)) {</span>
<span class="nc" id="L801">                slide++;</span>
<span class="nc" id="L802">                continue;</span>
            }
        }

<span class="nc" id="L806">        final int end = methods.length - slide;</span>
<span class="nc" id="L807">        Arrays.sort(methods, 0, end, methodPriority);</span>

<span class="nc bnc" id="L809" title="All 2 branches missed.">        for (int i = 0; i &lt; end; i++) {</span>
<span class="nc" id="L810">            Method m = methods[i];</span>
<span class="nc" id="L811">            Optional&lt;LambdaRequestHandler&gt; result = getHandlerFromOverload(handlerInfo.clazz, m);</span>
<span class="nc bnc" id="L812" title="All 2 branches missed.">            if (result.isPresent()) {</span>
<span class="nc" id="L813">                return result.get();</span>
            } else {
                continue;
            }
        }

<span class="nc" id="L819">        return new UserFaultHandler(makeUserFault(&quot;No public method named &quot;</span>
                + handlerInfo.methodName
                + &quot; with appropriate method signature found on class &quot;
<span class="nc" id="L822">                + handlerInfo.clazz.getName()));</span>
    }

    @SuppressWarnings({&quot;rawtypes&quot;})
    public static LambdaRequestHandler wrapPojoHandler(RequestHandler instance, Type pType, Type rType) {
<span class="nc" id="L827">        return wrapRequestStreamHandler(new PojoHandlerAsStreamHandler(instance, Optional.ofNullable(pType),</span>
<span class="nc bnc" id="L828" title="All 2 branches missed.">                isVoid(rType) ? Optional.&lt;Type&gt;empty() : Optional.of(rType)</span>
        ));
    }

    public static String exceptionToString(Throwable t) {
<span class="nc" id="L833">        StringWriter writer = new StringWriter(65536);</span>
<span class="nc" id="L834">        try (PrintWriter wrapped = new PrintWriter(writer)) {</span>
<span class="nc" id="L835">            t.printStackTrace(wrapped);</span>
        }
<span class="nc" id="L837">        StringBuffer buffer = writer.getBuffer();</span>
<span class="nc bnc" id="L838" title="All 2 branches missed.">        if (buffer.length() &gt; 262144) {</span>
<span class="nc" id="L839">            final String extra = &quot; Truncated by Lambda&quot;;</span>
<span class="nc" id="L840">            buffer.delete(262144, buffer.length());</span>
<span class="nc" id="L841">            buffer.append(extra);</span>
        }

<span class="nc" id="L844">        return buffer.toString();</span>
    }

    public static LambdaRequestHandler wrapRequestStreamHandler(final RequestStreamHandler handler) {
<span class="nc" id="L848">        return new LambdaRequestHandler() {</span>
<span class="nc" id="L849">            private final ByteArrayOutputStream output = new ByteArrayOutputStream(1024);</span>
<span class="nc" id="L850">            private Functions.V2&lt;String, String&gt; log4jContextPutMethod = null;</span>

            private void safeAddRequestIdToLog4j(String log4jContextClassName,
                                                 InvocationRequest request, Class contextMapValueClass) {
                try {
<span class="nc" id="L855">                    Class&lt;?&gt; log4jContextClass = ReflectUtil.loadClass(AWSLambda.customerClassLoader, log4jContextClassName);</span>
<span class="nc" id="L856">                    log4jContextPutMethod = ReflectUtil.loadStaticV2(log4jContextClass, &quot;put&quot;, false, String.class, contextMapValueClass);</span>
<span class="nc" id="L857">                    log4jContextPutMethod.call(&quot;AWSRequestId&quot;, request.getId());</span>
<span class="nc" id="L858">                } catch (Exception e) {}</span>
<span class="nc" id="L859">            }</span>

            public ByteArrayOutputStream call(InvocationRequest request) throws Error, Exception {
<span class="nc" id="L862">                output.reset();</span>

<span class="nc" id="L864">                LambdaCognitoIdentity cognitoIdentity = null;</span>
<span class="nc bnc" id="L865" title="All 4 branches missed.">                if(request.getCognitoIdentity() != null &amp;&amp; !request.getCognitoIdentity().isEmpty()) {</span>
<span class="nc" id="L866">                    cognitoIdentity = getCognitoSerializer().fromJson(request.getCognitoIdentity());</span>
                }

<span class="nc" id="L869">                LambdaClientContext clientContext = null;</span>
<span class="nc bnc" id="L870" title="All 4 branches missed.">                if (request.getClientContext() != null &amp;&amp; !request.getClientContext().isEmpty()) {</span>
                    //Use GSON here because it handles immutable types without requiring annotations
<span class="nc" id="L872">                    clientContext = getContextSerializer().fromJson(request.getClientContext());</span>
                }

<span class="nc" id="L875">                LambdaContext context = new LambdaContext(</span>
                        LambdaEnvironment.MEMORY_LIMIT,
<span class="nc" id="L877">                        request.getDeadlineTimeInMs(),</span>
<span class="nc" id="L878">                        request.getId(),</span>
                        LambdaEnvironment.LOG_GROUP_NAME,
                        LambdaEnvironment.LOG_STREAM_NAME,
                        LambdaEnvironment.FUNCTION_NAME,
                        cognitoIdentity,
                        LambdaEnvironment.FUNCTION_VERSION,
<span class="nc" id="L884">                        request.getInvokedFunctionArn(),</span>
                        clientContext
                );

<span class="nc bnc" id="L888" title="All 2 branches missed.">                if (LambdaRuntimeInternal.getUseLog4jAppender()) {</span>
<span class="nc" id="L889">                    safeAddRequestIdToLog4j(&quot;org.apache.log4j.MDC&quot;, request, Object.class);</span>
<span class="nc" id="L890">                    safeAddRequestIdToLog4j(&quot;org.apache.logging.log4j.ThreadContext&quot;, request, String.class);</span>
                    // if put method not assigned in either call to safeAddRequestIdtoLog4j then log4jContextPutMethod = null
<span class="nc bnc" id="L892" title="All 2 branches missed.">                    if (log4jContextPutMethod == null) {</span>
<span class="nc" id="L893">                        System.err.println(&quot;Customer using log4j appender but unable to load either &quot; +</span>
                                &quot;org.apache.log4j.MDC or org.apache.logging.log4j.ThreadContext. &quot; +
                                &quot;Customer cannot see RequestId in log4j log lines.&quot;);
                    }
                }

<span class="nc" id="L899">                handler.handleRequest(request.getContentAsStream(), output, context);</span>
<span class="nc" id="L900">                return output;</span>
            }
        };
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>